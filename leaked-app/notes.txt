Setup dynamically linked directories
====================================
1) ln -sf libaes.so.1.0 libaes.so.1
2) ln -sf libpassdb.so.1.0 libpassdb.so.1
3) export LD_LIBRARY_PATH=.


Tools to help project
=====================
- Browser-side debugger: https://developer.mozilla.org/en-US/docs/Tools/Debugger
    - Pretty print minified JavaScript: https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Pretty-print_a_minified_file
- Hardware Watchpoints: https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html
    - For example, using an rwatch command, you can cause the program to break 
      when a particular memory location is read. Similarly, a watch statement 
      will inform you whenever a particular memory location is written. You can 
      tell if your machine supports hardware-based watchpoints by issuing this 
      command from gdb: (gdb) show can-use-hw-watchpoints
- Note that Proton detaches itself from the console and runs in the background as a 
  daemon. So, as you run your experiments, you may need to check whether an 
  old copy of Proton is running before starting a new one. You can do a "pkill proton" to kill any old copy.


Exercise 1 Notes
=================
- strings: Interesting strings
	AES128_ECB_encrypt
	Content-Length: 136
	MSG_SEND: %s:%s
	FORBIDDEN: %s:%s
	Content-Length: 185
	?pw=
	&un=
	password.db
	&to=
	&msg=
	incoming_msg_buf
	inboxes/%s
	hint: proton Port-Number Top-Directory          version %d
	        proton is a small and very safe mini web server
	        proton only servers out file/web pages with extensions named below
	         and only from the named directory or its sub-directories.
	        There is no fancy features = safe and secure.
	        Example: proton 8080 /home/proton_dir &
	        Only Supports:
	        Not Supported: URLs including "..", Java, Javascript, CGI
	        Not Supported: directories / /etc /bin /lib /tmp /usr /dev /sbin
	        No warranty given or implied
- strace: didn't seem that helpful
- readelf: functions to look at:
	- load_passwd_file
	- close_passwd_file
	- AES128_ECB_decrypt
	- AES128_ECB_encrypt
	- AES128_ECB_decrypt
	- AES128_CBC_encrypt_buffer
	- AES128_CBC_decrypt_buffer

- Brute force way of getting root's password:
	- try every possible password and log if one works
- Hash function is pw_hash
- 1) Get key for AES (should be above function in the stack), then google
     around for how to decrypt AES
- check for process using "ps -Af | grep proton"
- gdb a specific process with "gdb -p XXX" where XXX is process id
- gdb follow on fork
- readelf -x gives a column of offsets
- offset: 0000204c of key
- objdump -t libpassdb.so.1 | less
- readelf -x .data libpassdb.so.1
- key = "3b99c216f1ae2dd69b70f5e800fc9aec"
- 2 hex chars is one byte
- 1) Find the offset of the variable key using 
	- run readelf -a libpassdb.so.1 | less
	- find line: 37: 0000204c    16 OBJECT  LOCAL  DEFAULT   22 key
	- 0000204c is the offset
- 2) Find what segment in memory key is in
	- run objdump -t libpassdb.so.1 | less
	- find line: 0000204c l     O .data  00000010              key
	- key is in the .data segment of memory
- 3) Find the actual key
	- print data segment in hexadecimal using readelf -x .data libpassdb.so.1
	- output starts at offset 0x00002048. key starts 4 bytes later and is 16
	  bytes long. 
	- key is 3b99c216f1ae2dd69b70f5e800fc9aec
- 4) Decrypt using http://aes.online-domain-tools.com/
- 5) File is decrypted_passworddb.bin

Exercise 2
===========
- Dictionary attack using GET requests
- Username: root, Password: bond007
- Username: 
	


